<head>
<style csss="">
    h5 { margin: 0; }
    .draggable { list-style: none; user-select: none; }
</style>
<script src="https://cdn.jsdelivr.net/gh/orstavik/doubledots@main25.05.13.13/dd.js"></script>
  <script type="module"
    src="https://cdn.jsdelivr.net/gh/orstavik/doubledots@main25.05.13.13/ddx.js?fetch_json&oi.~&embrace&Submit&Csss&Class&NAV&STATE~~&Click"
    _:define></script>
<script>
    document.Reactions.define("get-id", url => (url.searchParams.get("post")));
    document.Reactions.define("get-key", _ => (new URL(location.href).searchParams.get("key")));
    document.Reactions.define("get-post", ({snaps, id}) => snaps[id] ? snaps[id] : document.Reactions.break);
    document.Reactions.define("get-post-relation", ({post, key}) => post[key] ?? []);
    document.Reactions.define("get-post-type-key", ({snaps, key}) => (
        Object.keys(snaps)
            //check for key/key(s)
            .filter(k => [key, key.slice(0, -1)].includes(k.split("/")[0]))
    ));
    document.Reactions.define("diff", ({ relation, postkeytype }) => {
        return postkeytype.filter(key => !relation.includes(key));
    });
    document.Reactions.define("save-references", function(key) {
        if (!window.opener)
            return document.Reactions.break;
        const droppable = document.querySelector(".droppable");
        const draggables = droppable.querySelectorAll(".draggable");
        let references = [];
        for (let draggable of draggables)
            references.push(draggable.textContent);
        window.opener.postMessage({ type: "references", data: { key, references } }, location.origin);
        window.close();
    });
</script>
</head>
<body class="$bg(#f9fafb) $font(helvetica,arial,'sans-serif',500,capitalize) $flex(cc)" _::fetch_json:oi.value:state_snaps="/api/snap" nav:get-id:state_id>
    <div class="$flex(gap(2rem)) $h(min-content) |section$bg(white)" nav:get-key:state_key state_snaps_id:get-post:state_post state_post_key:get-post-relation:state_relation>
        <section template: state_relation:embrace>
            <h5 class="$bg(#dcfce7) $padding(1rem)">SELECTED</h5>
            <ul class="droppable $h(,100%,) $flex(column,gap(.5rem)) $padding(0,1rem) |li$border(solid,1px,radius(5px))$borderColor(#e5e7eb)$cursor(pointer)$padding(1rem)">
                <!-- <template for="item of relation"> -->
                    <li draggable="true" class="draggable">{{item}}</li>
                <!-- </template> -->
            </ul>
        </section>
        <section template: state_snaps_key:get-post-type-key:state_postKeyType state_postKeyType_relation:diff:embrace>
            <h5 class="$bg(#fef3c7) $padding(1rem)">NOT SELECTED</h5>
             <ul class="droppable $h(,100%,) $flex(column,gap(.5rem)) $padding(0,1rem) |li$border(solid,1px,radius(5px))$borderColor(#e5e7eb)$cursor(pointer)$padding(1rem)">
                <!-- <template for="item of $"> -->
                    <li draggable="true" class="draggable">{{item}}</li>
                <!-- </template> -->
            </ul>
        </section>
        <div>
            <button class="$padding(.8rem) $cursor(pointer) $bg(#4f46e5) $color(white,white) $em(.9rem) $border(solid,1px,radius(6px))" click:get-key:save-references>Save</button>
        </div>
    </div>
<script>
    (async() => {
        await DoubleDots.sleep(500);
        const draggables = document.querySelectorAll(".draggable");
        const droppables = document.querySelectorAll(".droppable");

        for (let draggable of draggables) {
            draggable.addEventListener("dragstart", () => draggable.classList.add("dragging"));
            draggable.addEventListener("dragend", () => draggable.classList.remove("dragging"));
        }
        for (let droppable of droppables) {
            droppable.addEventListener("dragover", e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(droppable, e.clientY)
                const draggable = document.querySelector('.dragging');
                if (afterElement == null) 
                    return droppable.appendChild(draggable)
                droppable.insertBefore(draggable, afterElement)
            });
        }

        function getDragAfterElement(droppable, y) {
            const draggableElements = [...droppable.querySelectorAll('.draggable:not(.dragging)')]
            return draggableElements.reduce((closest, element) => {
                const box = element.getBoundingClientRect()
                const offset = y - box.top - box.height / 2
                if (offset < 0 && offset > closest.offset) 
                    return { offset, element };
                return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element
        }
})();
</script>
</body>